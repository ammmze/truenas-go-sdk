/*
TrueNAS RESTful API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package truenas

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
)

// FilesystemApiService FilesystemApi service
type FilesystemApiService service

type FilesystemApiFilesystemAclIsTrivialPostRequest struct {
	ctx        context.Context
	ApiService *FilesystemApiService
	body       *string
}

func (r FilesystemApiFilesystemAclIsTrivialPostRequest) Body(body string) FilesystemApiFilesystemAclIsTrivialPostRequest {
	r.body = &body
	return r
}

func (r FilesystemApiFilesystemAclIsTrivialPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemAclIsTrivialPostExecute(r)
}

/*
FilesystemAclIsTrivialPost Method for FilesystemAclIsTrivialPost

Returns True if the ACL can be fully expressed as a file mode without losing
any access rules.

Paths on clustered volumes may be specifed with the path prefix
`CLUSTER:<volume name>`. For example, to list directories
in the directory 'data' in the clustered volume `smb01`, the
path should be specified as `CLUSTER:smb01/data`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemAclIsTrivialPostRequest
*/
func (a *FilesystemApiService) FilesystemAclIsTrivialPost(ctx context.Context) FilesystemApiFilesystemAclIsTrivialPostRequest {
	return FilesystemApiFilesystemAclIsTrivialPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemAclIsTrivialPostExecute(r FilesystemApiFilesystemAclIsTrivialPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemAclIsTrivialPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/acl_is_trivial"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemCanAccessAsUserPostRequest struct {
	ctx                       context.Context
	ApiService                *FilesystemApiService
	filesystemCanAccessAsUser *FilesystemCanAccessAsUser
}

func (r FilesystemApiFilesystemCanAccessAsUserPostRequest) FilesystemCanAccessAsUser(filesystemCanAccessAsUser FilesystemCanAccessAsUser) FilesystemApiFilesystemCanAccessAsUserPostRequest {
	r.filesystemCanAccessAsUser = &filesystemCanAccessAsUser
	return r
}

func (r FilesystemApiFilesystemCanAccessAsUserPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemCanAccessAsUserPostExecute(r)
}

/*
FilesystemCanAccessAsUserPost Method for FilesystemCanAccessAsUserPost

Check if `username` is able to access `path` with specific `permissions`. At least one of `read/write/execute`
permission must be specified for checking with each of these defaulting to `null`. `null` for
`read/write/execute` represents that the permission should not be checked.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemCanAccessAsUserPostRequest
*/
func (a *FilesystemApiService) FilesystemCanAccessAsUserPost(ctx context.Context) FilesystemApiFilesystemCanAccessAsUserPostRequest {
	return FilesystemApiFilesystemCanAccessAsUserPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemCanAccessAsUserPostExecute(r FilesystemApiFilesystemCanAccessAsUserPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemCanAccessAsUserPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/can_access_as_user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filesystemCanAccessAsUser
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemChownPostRequest struct {
	ctx              context.Context
	ApiService       *FilesystemApiService
	filesystemChown0 *FilesystemChown0
}

func (r FilesystemApiFilesystemChownPostRequest) FilesystemChown0(filesystemChown0 FilesystemChown0) FilesystemApiFilesystemChownPostRequest {
	r.filesystemChown0 = &filesystemChown0
	return r
}

func (r FilesystemApiFilesystemChownPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemChownPostExecute(r)
}

/*
FilesystemChownPost Method for FilesystemChownPost

Change owner or group of file at `path`.

`uid` and `gid` specify new owner of the file. If either
key is absent or None, then existing value on the file is not
changed.

`recursive` performs action recursively, but does
not traverse filesystem mount points.

If `traverse` and `recursive` are specified, then the chown
operation will traverse filesystem mount points.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemChownPostRequest
*/
func (a *FilesystemApiService) FilesystemChownPost(ctx context.Context) FilesystemApiFilesystemChownPostRequest {
	return FilesystemApiFilesystemChownPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemChownPostExecute(r FilesystemApiFilesystemChownPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemChownPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/chown"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filesystemChown0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemDefaultAclChoicesPostRequest struct {
	ctx        context.Context
	ApiService *FilesystemApiService
	body       *string
}

func (r FilesystemApiFilesystemDefaultAclChoicesPostRequest) Body(body string) FilesystemApiFilesystemDefaultAclChoicesPostRequest {
	r.body = &body
	return r
}

func (r FilesystemApiFilesystemDefaultAclChoicesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemDefaultAclChoicesPostExecute(r)
}

/*
FilesystemDefaultAclChoicesPost Method for FilesystemDefaultAclChoicesPost

`DEPRECATED`
Returns list of names of ACL templates. Wrapper around
filesystem.acltemplate.query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemDefaultAclChoicesPostRequest
*/
func (a *FilesystemApiService) FilesystemDefaultAclChoicesPost(ctx context.Context) FilesystemApiFilesystemDefaultAclChoicesPostRequest {
	return FilesystemApiFilesystemDefaultAclChoicesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemDefaultAclChoicesPostExecute(r FilesystemApiFilesystemDefaultAclChoicesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemDefaultAclChoicesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/default_acl_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemGetDefaultAclPostRequest struct {
	ctx                     context.Context
	ApiService              *FilesystemApiService
	filesystemGetDefaultAcl *FilesystemGetDefaultAcl
}

func (r FilesystemApiFilesystemGetDefaultAclPostRequest) FilesystemGetDefaultAcl(filesystemGetDefaultAcl FilesystemGetDefaultAcl) FilesystemApiFilesystemGetDefaultAclPostRequest {
	r.filesystemGetDefaultAcl = &filesystemGetDefaultAcl
	return r
}

func (r FilesystemApiFilesystemGetDefaultAclPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemGetDefaultAclPostExecute(r)
}

/*
FilesystemGetDefaultAclPost Method for FilesystemGetDefaultAclPost

`DEPRECATED`
Returns a default ACL depending on the usage specified by `acl_type`.
If an admin group is defined, then an entry granting it full control will
be placed at the top of the ACL. Optionally may pass `share_type` to argument
to get share-specific template ACL.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemGetDefaultAclPostRequest
*/
func (a *FilesystemApiService) FilesystemGetDefaultAclPost(ctx context.Context) FilesystemApiFilesystemGetDefaultAclPostRequest {
	return FilesystemApiFilesystemGetDefaultAclPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemGetDefaultAclPostExecute(r FilesystemApiFilesystemGetDefaultAclPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemGetDefaultAclPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/get_default_acl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filesystemGetDefaultAcl
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemGetDosmodePostRequest struct {
	ctx        context.Context
	ApiService *FilesystemApiService
	body       *string
}

func (r FilesystemApiFilesystemGetDosmodePostRequest) Body(body string) FilesystemApiFilesystemGetDosmodePostRequest {
	r.body = &body
	return r
}

func (r FilesystemApiFilesystemGetDosmodePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemGetDosmodePostExecute(r)
}

/*
FilesystemGetDosmodePost Method for FilesystemGetDosmodePost



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemGetDosmodePostRequest
*/
func (a *FilesystemApiService) FilesystemGetDosmodePost(ctx context.Context) FilesystemApiFilesystemGetDosmodePostRequest {
	return FilesystemApiFilesystemGetDosmodePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemGetDosmodePostExecute(r FilesystemApiFilesystemGetDosmodePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemGetDosmodePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/get_dosmode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemGetPostRequest struct {
	ctx        context.Context
	ApiService *FilesystemApiService
	body       *string
}

func (r FilesystemApiFilesystemGetPostRequest) Body(body string) FilesystemApiFilesystemGetPostRequest {
	r.body = &body
	return r
}

func (r FilesystemApiFilesystemGetPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemGetPostExecute(r)
}

/*
FilesystemGetPost Method for FilesystemGetPost

Job to get contents of `path`.

A file will be downloaded from this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemGetPostRequest
*/
func (a *FilesystemApiService) FilesystemGetPost(ctx context.Context) FilesystemApiFilesystemGetPostRequest {
	return FilesystemApiFilesystemGetPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemGetPostExecute(r FilesystemApiFilesystemGetPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemGetPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemGetaclPostRequest struct {
	ctx              context.Context
	ApiService       *FilesystemApiService
	filesystemGetacl *FilesystemGetacl
}

func (r FilesystemApiFilesystemGetaclPostRequest) FilesystemGetacl(filesystemGetacl FilesystemGetacl) FilesystemApiFilesystemGetaclPostRequest {
	r.filesystemGetacl = &filesystemGetacl
	return r
}

func (r FilesystemApiFilesystemGetaclPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemGetaclPostExecute(r)
}

/*
FilesystemGetaclPost Method for FilesystemGetaclPost

Return ACL of a given path. This may return a POSIX1e ACL or a NFSv4 ACL. The acl type is indicated
by the `acltype` key.

`simplified` - effect of this depends on ACL type on underlying filesystem. In the case of
NFSv4 ACLs simplified permissions and flags are returned for ACL entries where applicable.
NFSv4 errata below. In the case of POSIX1E ACls, this setting has no impact on returned ACL.

`resolve_ids` - adds additional `who` key to each ACL entry, that converts the numeric id to
a user name or group name. In the case of owner@ and group@ (NFSv4) or USER_OBJ and GROUP_OBJ
(POSIX1E), st_uid or st_gid will be converted from stat() return for file. In the case of
MASK (POSIX1E), OTHER (POSIX1E), everyone@ (NFSv4), key `who` will be included, but set to null.
In case of failure to resolve the id to a name, `who` will be set to null. This option should
only be used if resolving ids to names is required.

Errata about ACLType NFSv4:

`simplified` returns a shortened form of the ACL permset and flags where applicable. If permissions
have been simplified, then the `perms` object will contain only a single `BASIC` key with a string
describing the underlying permissions set.

`TRAVERSE` sufficient rights to traverse a directory, but not read contents.

`READ` sufficient rights to traverse a directory, and read file contents.

`MODIFIY` sufficient rights to traverse, read, write, and modify a file.

`FULL_CONTROL` all permissions.

If the permisssions do not fit within one of the pre-defined simplified permissions types, then
the full ACL entry will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemGetaclPostRequest
*/
func (a *FilesystemApiService) FilesystemGetaclPost(ctx context.Context) FilesystemApiFilesystemGetaclPostRequest {
	return FilesystemApiFilesystemGetaclPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemGetaclPostExecute(r FilesystemApiFilesystemGetaclPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemGetaclPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/getacl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filesystemGetacl
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemIsImmutablePostRequest struct {
	ctx        context.Context
	ApiService *FilesystemApiService
	body       *string
}

func (r FilesystemApiFilesystemIsImmutablePostRequest) Body(body string) FilesystemApiFilesystemIsImmutablePostRequest {
	r.body = &body
	return r
}

func (r FilesystemApiFilesystemIsImmutablePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemIsImmutablePostExecute(r)
}

/*
FilesystemIsImmutablePost Method for FilesystemIsImmutablePost

Retrieves boolean which is set when immutable flag is set on `path`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemIsImmutablePostRequest
*/
func (a *FilesystemApiService) FilesystemIsImmutablePost(ctx context.Context) FilesystemApiFilesystemIsImmutablePostRequest {
	return FilesystemApiFilesystemIsImmutablePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemIsImmutablePostExecute(r FilesystemApiFilesystemIsImmutablePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemIsImmutablePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/is_immutable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemListdirPostRequest struct {
	ctx               context.Context
	ApiService        *FilesystemApiService
	filesystemListdir *FilesystemListdir
}

func (r FilesystemApiFilesystemListdirPostRequest) FilesystemListdir(filesystemListdir FilesystemListdir) FilesystemApiFilesystemListdirPostRequest {
	r.filesystemListdir = &filesystemListdir
	return r
}

func (r FilesystemApiFilesystemListdirPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemListdirPostExecute(r)
}

/*
FilesystemListdirPost Method for FilesystemListdirPost

Get the contents of a directory.

Paths on clustered volumes may be specifed with the path prefix
`CLUSTER:<volume name>`. For example, to list directories
in the directory 'data' in the clustered volume `smb01`, the
path should be specified as `CLUSTER:smb01/data`.

Each entry of the list consists of:
  name(str): name of the file
  path(str): absolute path of the entry
  realpath(str): absolute real path of the entry (if SYMLINK)
  type(str): DIRECTORY | FILE | SYMLINK | OTHER
  size(int): size of the entry
  mode(int): file mode/permission
  uid(int): user id of entry owner
  gid(int): group id of entry onwer
  acl(bool): extended ACL is present on file
  is_mountpoint(bool): path is a mountpoint
  is_ctldir(bool): path is within special .zfs directory

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemListdirPostRequest
*/
func (a *FilesystemApiService) FilesystemListdirPost(ctx context.Context) FilesystemApiFilesystemListdirPostRequest {
	return FilesystemApiFilesystemListdirPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemListdirPostExecute(r FilesystemApiFilesystemListdirPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemListdirPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/listdir"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filesystemListdir
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemMkdirPostRequest struct {
	ctx        context.Context
	ApiService *FilesystemApiService
	body       *string
}

func (r FilesystemApiFilesystemMkdirPostRequest) Body(body string) FilesystemApiFilesystemMkdirPostRequest {
	r.body = &body
	return r
}

func (r FilesystemApiFilesystemMkdirPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemMkdirPostExecute(r)
}

/*
FilesystemMkdirPost Method for FilesystemMkdirPost

Create a directory at the specified path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemMkdirPostRequest
*/
func (a *FilesystemApiService) FilesystemMkdirPost(ctx context.Context) FilesystemApiFilesystemMkdirPostRequest {
	return FilesystemApiFilesystemMkdirPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemMkdirPostExecute(r FilesystemApiFilesystemMkdirPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemMkdirPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/mkdir"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemPutPostRequest struct {
	ctx           context.Context
	ApiService    *FilesystemApiService
	filesystemPut *FilesystemPut
}

func (r FilesystemApiFilesystemPutPostRequest) FilesystemPut(filesystemPut FilesystemPut) FilesystemApiFilesystemPutPostRequest {
	r.filesystemPut = &filesystemPut
	return r
}

func (r FilesystemApiFilesystemPutPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemPutPostExecute(r)
}

/*
FilesystemPutPost Method for FilesystemPutPost

Job to put contents to `path`.

A file must be uploaded to this endpoint. To upload a file, please send a multipart request with two parts. The first, named `data`, should contain a JSON-encoded payload, and the second, named `file`, should contain an uploaded file.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemPutPostRequest
*/
func (a *FilesystemApiService) FilesystemPutPost(ctx context.Context) FilesystemApiFilesystemPutPostRequest {
	return FilesystemApiFilesystemPutPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemPutPostExecute(r FilesystemApiFilesystemPutPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemPutPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/put"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filesystemPut
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemSetDosmodePostRequest struct {
	ctx                   context.Context
	ApiService            *FilesystemApiService
	filesystemSetDosmode0 *FilesystemSetDosmode0
}

func (r FilesystemApiFilesystemSetDosmodePostRequest) FilesystemSetDosmode0(filesystemSetDosmode0 FilesystemSetDosmode0) FilesystemApiFilesystemSetDosmodePostRequest {
	r.filesystemSetDosmode0 = &filesystemSetDosmode0
	return r
}

func (r FilesystemApiFilesystemSetDosmodePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemSetDosmodePostExecute(r)
}

/*
FilesystemSetDosmodePost Method for FilesystemSetDosmodePost



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemSetDosmodePostRequest
*/
func (a *FilesystemApiService) FilesystemSetDosmodePost(ctx context.Context) FilesystemApiFilesystemSetDosmodePostRequest {
	return FilesystemApiFilesystemSetDosmodePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemSetDosmodePostExecute(r FilesystemApiFilesystemSetDosmodePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemSetDosmodePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/set_dosmode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filesystemSetDosmode0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemSetImmutablePostRequest struct {
	ctx                    context.Context
	ApiService             *FilesystemApiService
	filesystemSetImmutable *FilesystemSetImmutable
}

func (r FilesystemApiFilesystemSetImmutablePostRequest) FilesystemSetImmutable(filesystemSetImmutable FilesystemSetImmutable) FilesystemApiFilesystemSetImmutablePostRequest {
	r.filesystemSetImmutable = &filesystemSetImmutable
	return r
}

func (r FilesystemApiFilesystemSetImmutablePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemSetImmutablePostExecute(r)
}

/*
FilesystemSetImmutablePost Method for FilesystemSetImmutablePost

Set/Unset immutable flag at `path`.

`set_flag` when set will set immutable flag and when unset will unset immutable flag at `path`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemSetImmutablePostRequest
*/
func (a *FilesystemApiService) FilesystemSetImmutablePost(ctx context.Context) FilesystemApiFilesystemSetImmutablePostRequest {
	return FilesystemApiFilesystemSetImmutablePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemSetImmutablePostExecute(r FilesystemApiFilesystemSetImmutablePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemSetImmutablePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/set_immutable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filesystemSetImmutable
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemSetaclPostRequest struct {
	ctx               context.Context
	ApiService        *FilesystemApiService
	filesystemSetacl0 *FilesystemSetacl0
}

func (r FilesystemApiFilesystemSetaclPostRequest) FilesystemSetacl0(filesystemSetacl0 FilesystemSetacl0) FilesystemApiFilesystemSetaclPostRequest {
	r.filesystemSetacl0 = &filesystemSetacl0
	return r
}

func (r FilesystemApiFilesystemSetaclPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemSetaclPostExecute(r)
}

/*
FilesystemSetaclPost Method for FilesystemSetaclPost

Set ACL of a given path. Takes the following parameters:
`path` full path to directory or file.

Paths on clustered volumes may be specifed with the path prefix
`CLUSTER:<volume name>`. For example, to list directories
in the directory 'data' in the clustered volume `smb01`, the
path should be specified as `CLUSTER:smb01/data`.

`dacl` ACL entries. Formatting depends on the underlying `acltype`. NFS4ACL requires
NFSv4 entries. POSIX1e requires POSIX1e entries.

`uid` the desired UID of the file user. If set to None (the default), then user is not changed.

`gid` the desired GID of the file group. If set to None (the default), then group is not changed.

`recursive` apply the ACL recursively

`traverse` traverse filestem boundaries (ZFS datasets)

`strip` convert ACL to trivial. ACL is trivial if it can be expressed as a file mode without
losing any access rules.

`canonicalize` reorder ACL entries so that they are in concanical form as described
in the Microsoft documentation MS-DTYP 2.4.5 (ACL). This only applies to NFSv4 ACLs.

For case of NFSv4 ACLs  USER_OBJ, GROUP_OBJ, and EVERYONE with owner@, group@, everyone@ for
consistency with getfacl and setfacl. If one of aforementioned special tags is used, 'id' must
be set to None.

An inheriting empty everyone@ ACE is appended to non-trivial ACLs in order to enforce Windows
expectations regarding permissions inheritance. This entry is removed from NT ACL returned
to SMB clients when 'ixnas' samba VFS module is enabled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemSetaclPostRequest
*/
func (a *FilesystemApiService) FilesystemSetaclPost(ctx context.Context) FilesystemApiFilesystemSetaclPostRequest {
	return FilesystemApiFilesystemSetaclPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemSetaclPostExecute(r FilesystemApiFilesystemSetaclPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemSetaclPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/setacl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filesystemSetacl0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemSetpermPostRequest struct {
	ctx                context.Context
	ApiService         *FilesystemApiService
	filesystemSetperm0 *FilesystemSetperm0
}

func (r FilesystemApiFilesystemSetpermPostRequest) FilesystemSetperm0(filesystemSetperm0 FilesystemSetperm0) FilesystemApiFilesystemSetpermPostRequest {
	r.filesystemSetperm0 = &filesystemSetperm0
	return r
}

func (r FilesystemApiFilesystemSetpermPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemSetpermPostExecute(r)
}

/*
FilesystemSetpermPost Method for FilesystemSetpermPost

Set unix permissions on given `path`.

Paths on clustered volumes may be specifed with the path prefix
`CLUSTER:<volume name>`. For example, to list directories
in the directory 'data' in the clustered volume `smb01`, the
path should be specified as `CLUSTER:smb01/data`.

If `mode` is specified then the mode will be applied to the
path and files and subdirectories depending on which `options` are
selected. Mode should be formatted as string representation of octal
permissions bits.

`uid` the desired UID of the file user. If set to None (the default), then user is not changed.

`gid` the desired GID of the file group. If set to None (the default), then group is not changed.

`stripacl` setperm will fail if an extended ACL is present on `path`,
unless `stripacl` is set to True.

`recursive` remove ACLs recursively, but do not traverse dataset
boundaries.

`traverse` remove ACLs from child datasets.

If no `mode` is set, and `stripacl` is True, then non-trivial ACLs
will be converted to trivial ACLs. An ACL is trivial if it can be
expressed as a file mode without losing any access rules.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemSetpermPostRequest
*/
func (a *FilesystemApiService) FilesystemSetpermPost(ctx context.Context) FilesystemApiFilesystemSetpermPostRequest {
	return FilesystemApiFilesystemSetpermPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemSetpermPostExecute(r FilesystemApiFilesystemSetpermPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemSetpermPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/setperm"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.filesystemSetperm0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemStatPostRequest struct {
	ctx        context.Context
	ApiService *FilesystemApiService
	body       *string
}

func (r FilesystemApiFilesystemStatPostRequest) Body(body string) FilesystemApiFilesystemStatPostRequest {
	r.body = &body
	return r
}

func (r FilesystemApiFilesystemStatPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemStatPostExecute(r)
}

/*
FilesystemStatPost Method for FilesystemStatPost

Return the filesystem stat(2) for a given `path`.

Paths on clustered volumes may be specifed with the path prefix
`CLUSTER:<volume name>`. For example, to list directories
in the directory 'data' in the clustered volume `smb01`, the
path should be specified as `CLUSTER:smb01/data`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemStatPostRequest
*/
func (a *FilesystemApiService) FilesystemStatPost(ctx context.Context) FilesystemApiFilesystemStatPostRequest {
	return FilesystemApiFilesystemStatPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemStatPostExecute(r FilesystemApiFilesystemStatPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemStatPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/stat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type FilesystemApiFilesystemStatfsPostRequest struct {
	ctx        context.Context
	ApiService *FilesystemApiService
	body       *string
}

func (r FilesystemApiFilesystemStatfsPostRequest) Body(body string) FilesystemApiFilesystemStatfsPostRequest {
	r.body = &body
	return r
}

func (r FilesystemApiFilesystemStatfsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.FilesystemStatfsPostExecute(r)
}

/*
FilesystemStatfsPost Method for FilesystemStatfsPost

Return stats from the filesystem of a given path.

Paths on clustered volumes may be specifed with the path prefix
`CLUSTER:<volume name>`. For example, to list directories
in the directory 'data' in the clustered volume `smb01`, the
path should be specified as `CLUSTER:smb01/data`.

Raises:
    CallError(ENOENT) - Path not found

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return FilesystemApiFilesystemStatfsPostRequest
*/
func (a *FilesystemApiService) FilesystemStatfsPost(ctx context.Context) FilesystemApiFilesystemStatfsPostRequest {
	return FilesystemApiFilesystemStatfsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *FilesystemApiService) FilesystemStatfsPostExecute(r FilesystemApiFilesystemStatfsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesystemApiService.FilesystemStatfsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/filesystem/statfs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
