/*
 * TrueNAS RESTful API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v2.0
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package truenas

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// SmbSharesecApiService SmbSharesecApi service
type SmbSharesecApiService service

type ApiSmbSharesecGetRequest struct {
	ctx _context.Context
	ApiService *SmbSharesecApiService
	limit *int32
	offset *int32
	count *bool
	sort *string
}

func (r ApiSmbSharesecGetRequest) Limit(limit int32) ApiSmbSharesecGetRequest {
	r.limit = &limit
	return r
}
func (r ApiSmbSharesecGetRequest) Offset(offset int32) ApiSmbSharesecGetRequest {
	r.offset = &offset
	return r
}
func (r ApiSmbSharesecGetRequest) Count(count bool) ApiSmbSharesecGetRequest {
	r.count = &count
	return r
}
func (r ApiSmbSharesecGetRequest) Sort(sort string) ApiSmbSharesecGetRequest {
	r.sort = &sort
	return r
}

func (r ApiSmbSharesecGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SmbSharesecGetExecute(r)
}

/*
 * SmbSharesecGet Method for SmbSharesecGet
 * Use query-filters to search the SMB share ACLs present on server.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSmbSharesecGetRequest
 */
func (a *SmbSharesecApiService) SmbSharesecGet(ctx _context.Context) ApiSmbSharesecGetRequest {
	return ApiSmbSharesecGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *SmbSharesecApiService) SmbSharesecGetExecute(r ApiSmbSharesecGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecGetaclPostRequest struct {
	ctx _context.Context
	ApiService *SmbSharesecApiService
	smbSharesecGetacl *SmbSharesecGetacl
}

func (r ApiSmbSharesecGetaclPostRequest) SmbSharesecGetacl(smbSharesecGetacl SmbSharesecGetacl) ApiSmbSharesecGetaclPostRequest {
	r.smbSharesecGetacl = &smbSharesecGetacl
	return r
}

func (r ApiSmbSharesecGetaclPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SmbSharesecGetaclPostExecute(r)
}

/*
 * SmbSharesecGetaclPost Method for SmbSharesecGetaclPost
 * View the ACL information for `share_name`. The share ACL is distinct from filesystem
ACLs which can be viewed by calling `filesystem.getacl`. `ae_who_name` will appear
as `None` if the SMB service is stopped or if winbind is unable  to resolve the SID
to a name.

If the `option` `resolve_sids` is set to `False` then the returned ACL will not
contain names.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSmbSharesecGetaclPostRequest
 */
func (a *SmbSharesecApiService) SmbSharesecGetaclPost(ctx _context.Context) ApiSmbSharesecGetaclPostRequest {
	return ApiSmbSharesecGetaclPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *SmbSharesecApiService) SmbSharesecGetaclPostExecute(r ApiSmbSharesecGetaclPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecGetaclPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/getacl"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.smbSharesecGetacl
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecIdIdDeleteRequest struct {
	ctx _context.Context
	ApiService *SmbSharesecApiService
	id string
}


func (r ApiSmbSharesecIdIdDeleteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SmbSharesecIdIdDeleteExecute(r)
}

/*
 * SmbSharesecIdIdDelete Method for SmbSharesecIdIdDelete
 * Replace share ACL for the specified SMB share with the samba default ACL of S-1-1-0/FULL
(Everyone - Full Control). In this case, access will be fully determined
by the underlying filesystem ACLs and smb4.conf parameters governing access control
and permissions.
Share can be deleted by name or numerical by numerical index.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiSmbSharesecIdIdDeleteRequest
 */
func (a *SmbSharesecApiService) SmbSharesecIdIdDelete(ctx _context.Context, id string) ApiSmbSharesecIdIdDeleteRequest {
	return ApiSmbSharesecIdIdDeleteRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *SmbSharesecApiService) SmbSharesecIdIdDeleteExecute(r ApiSmbSharesecIdIdDeleteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecIdIdDelete")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecIdIdGetRequest struct {
	ctx _context.Context
	ApiService *SmbSharesecApiService
	id []interface{}
	limit *int32
	offset *int32
	count *bool
	sort *string
}

func (r ApiSmbSharesecIdIdGetRequest) Limit(limit int32) ApiSmbSharesecIdIdGetRequest {
	r.limit = &limit
	return r
}
func (r ApiSmbSharesecIdIdGetRequest) Offset(offset int32) ApiSmbSharesecIdIdGetRequest {
	r.offset = &offset
	return r
}
func (r ApiSmbSharesecIdIdGetRequest) Count(count bool) ApiSmbSharesecIdIdGetRequest {
	r.count = &count
	return r
}
func (r ApiSmbSharesecIdIdGetRequest) Sort(sort string) ApiSmbSharesecIdIdGetRequest {
	r.sort = &sort
	return r
}

func (r ApiSmbSharesecIdIdGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SmbSharesecIdIdGetExecute(r)
}

/*
 * SmbSharesecIdIdGet Method for SmbSharesecIdIdGet
 * Use query-filters to search the SMB share ACLs present on server.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiSmbSharesecIdIdGetRequest
 */
func (a *SmbSharesecApiService) SmbSharesecIdIdGet(ctx _context.Context, id []interface{}) ApiSmbSharesecIdIdGetRequest {
	return ApiSmbSharesecIdIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *SmbSharesecApiService) SmbSharesecIdIdGetExecute(r ApiSmbSharesecIdIdGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecIdIdGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "csv")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecIdIdPutRequest struct {
	ctx _context.Context
	ApiService *SmbSharesecApiService
	id int32
	smbSharesecUpdate1 *SmbSharesecUpdate1
}

func (r ApiSmbSharesecIdIdPutRequest) SmbSharesecUpdate1(smbSharesecUpdate1 SmbSharesecUpdate1) ApiSmbSharesecIdIdPutRequest {
	r.smbSharesecUpdate1 = &smbSharesecUpdate1
	return r
}

func (r ApiSmbSharesecIdIdPutRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SmbSharesecIdIdPutExecute(r)
}

/*
 * SmbSharesecIdIdPut Method for SmbSharesecIdIdPut
 * Update the ACL on the share specified by the numerical index `id`. Will write changes
to both /var/db/system/samba4/share_info.tdb and the configuration file.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @return ApiSmbSharesecIdIdPutRequest
 */
func (a *SmbSharesecApiService) SmbSharesecIdIdPut(ctx _context.Context, id int32) ApiSmbSharesecIdIdPutRequest {
	return ApiSmbSharesecIdIdPutRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 */
func (a *SmbSharesecApiService) SmbSharesecIdIdPutExecute(r ApiSmbSharesecIdIdPutRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecIdIdPut")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.smbSharesecUpdate1
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecPostRequest struct {
	ctx _context.Context
	ApiService *SmbSharesecApiService
	smbSharesecCreate0 *SmbSharesecCreate0
}

func (r ApiSmbSharesecPostRequest) SmbSharesecCreate0(smbSharesecCreate0 SmbSharesecCreate0) ApiSmbSharesecPostRequest {
	r.smbSharesecCreate0 = &smbSharesecCreate0
	return r
}

func (r ApiSmbSharesecPostRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SmbSharesecPostExecute(r)
}

/*
 * SmbSharesecPost Method for SmbSharesecPost
 * Update the ACL on a given SMB share. Will write changes to both
/var/db/system/samba4/share_info.tdb and the configuration file.
Since an SMB share will _always_ have an ACL present, there is little
distinction between the `create` and `update` methods apart from arguments.

`share_name` - name of SMB share.

`share_acl` a list of ACL entries (dictionaries) with the following keys:

`ae_who_sid` who the ACL entry applies to expressed as a Windows SID

`ae_who_name` who the ACL entry applies to expressed as a name. `ae_who_name` is
a dictionary containing the following keys: `domain` that the user is a member of,
`name` username in the domain. The domain for local users is the netbios name of
the FreeNAS server.

`ae_perm` string representation of the permissions granted to the user or group.
`FULL` grants read, write, execute, delete, write acl, and change owner.
`CHANGE` grants read, write, execute, and delete.
`READ` grants read and execute.

`ae_type` can be ALLOWED or DENIED.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSmbSharesecPostRequest
 */
func (a *SmbSharesecApiService) SmbSharesecPost(ctx _context.Context) ApiSmbSharesecPostRequest {
	return ApiSmbSharesecPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *SmbSharesecApiService) SmbSharesecPostExecute(r ApiSmbSharesecPostRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecPost")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.smbSharesecCreate0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSmbSharesecSynchronizeAclsGetRequest struct {
	ctx _context.Context
	ApiService *SmbSharesecApiService
}


func (r ApiSmbSharesecSynchronizeAclsGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.SmbSharesecSynchronizeAclsGetExecute(r)
}

/*
 * SmbSharesecSynchronizeAclsGet Method for SmbSharesecSynchronizeAclsGet
 * Synchronize the share ACL stored in the config database with Samba's running
configuration as reflected in the share_info.tdb file.

The only situation in which the configuration stored in the database will
overwrite samba's running configuration is if share_info.tdb is empty. Samba
fakes a single S-1-1-0:ALLOW/0x0/FULL entry in the absence of an entry for a
share in share_info.tdb.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiSmbSharesecSynchronizeAclsGetRequest
 */
func (a *SmbSharesecApiService) SmbSharesecSynchronizeAclsGet(ctx _context.Context) ApiSmbSharesecSynchronizeAclsGetRequest {
	return ApiSmbSharesecSynchronizeAclsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *SmbSharesecApiService) SmbSharesecSynchronizeAclsGetExecute(r ApiSmbSharesecSynchronizeAclsGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SmbSharesecApiService.SmbSharesecSynchronizeAclsGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/smb/sharesec/synchronize_acls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
