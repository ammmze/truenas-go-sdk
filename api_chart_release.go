/*
TrueNAS RESTful API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package truenas

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// ChartReleaseApiService ChartReleaseApi service
type ChartReleaseApiService service

type ChartReleaseApiChartReleaseCertificateAuthorityChoicesGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
}

func (r ChartReleaseApiChartReleaseCertificateAuthorityChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseCertificateAuthorityChoicesGetExecute(r)
}

/*
ChartReleaseCertificateAuthorityChoicesGet Method for ChartReleaseCertificateAuthorityChoicesGet

Returns certificate authorities which can be used by applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseCertificateAuthorityChoicesGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseCertificateAuthorityChoicesGet(ctx context.Context) ChartReleaseApiChartReleaseCertificateAuthorityChoicesGetRequest {
	return ChartReleaseApiChartReleaseCertificateAuthorityChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseCertificateAuthorityChoicesGetExecute(r ChartReleaseApiChartReleaseCertificateAuthorityChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseCertificateAuthorityChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/certificate_authority_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseCertificateChoicesGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
}

func (r ChartReleaseApiChartReleaseCertificateChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseCertificateChoicesGetExecute(r)
}

/*
ChartReleaseCertificateChoicesGet Method for ChartReleaseCertificateChoicesGet

Returns certificates which can be used by applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseCertificateChoicesGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseCertificateChoicesGet(ctx context.Context) ChartReleaseApiChartReleaseCertificateChoicesGetRequest {
	return ChartReleaseApiChartReleaseCertificateChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseCertificateChoicesGetExecute(r ChartReleaseApiChartReleaseCertificateChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseCertificateChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/certificate_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseEventsPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ChartReleaseApiChartReleaseEventsPostRequest) Body(body string) ChartReleaseApiChartReleaseEventsPostRequest {
	r.body = &body
	return r
}

func (r ChartReleaseApiChartReleaseEventsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseEventsPostExecute(r)
}

/*
ChartReleaseEventsPost Method for ChartReleaseEventsPost

Returns kubernetes events for `release_name` Chart Release.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseEventsPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseEventsPost(ctx context.Context) ChartReleaseApiChartReleaseEventsPostRequest {
	return ChartReleaseApiChartReleaseEventsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseEventsPostExecute(r ChartReleaseApiChartReleaseEventsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseEventsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	limit      *int32
	offset     *int32
	count      *bool
	sort       *string
}

func (r ChartReleaseApiChartReleaseGetRequest) Limit(limit int32) ChartReleaseApiChartReleaseGetRequest {
	r.limit = &limit
	return r
}

func (r ChartReleaseApiChartReleaseGetRequest) Offset(offset int32) ChartReleaseApiChartReleaseGetRequest {
	r.offset = &offset
	return r
}

func (r ChartReleaseApiChartReleaseGetRequest) Count(count bool) ChartReleaseApiChartReleaseGetRequest {
	r.count = &count
	return r
}

func (r ChartReleaseApiChartReleaseGetRequest) Sort(sort string) ChartReleaseApiChartReleaseGetRequest {
	r.sort = &sort
	return r
}

func (r ChartReleaseApiChartReleaseGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseGetExecute(r)
}

/*
ChartReleaseGet Method for ChartReleaseGet

Query available chart releases.

`query-options.extra.retrieve_resources` is a boolean when set will retrieve existing kubernetes resources
in the chart namespace.

`query-options.extra.history` is a boolean when set will retrieve all chart version upgrades
for a chart release.

`query-options.extra.include_chart_schema` is a boolean when set will retrieve the schema being used by
the chart release in question.

`query-options.extra.resource_events` is a boolean when set will retrieve individual events of each resource.
This only has effect if `query-options.extra.retrieve_resources` is set.

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseGet(ctx context.Context) ChartReleaseApiChartReleaseGetRequest {
	return ChartReleaseApiChartReleaseGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseGetExecute(r ChartReleaseApiChartReleaseGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseIdIdDeleteRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	id         string
}

func (r ChartReleaseApiChartReleaseIdIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseIdIdDeleteExecute(r)
}

/*
ChartReleaseIdIdDelete Method for ChartReleaseIdIdDelete

Delete existing chart release.

This will delete the chart release from the kubernetes cluster and also remove any associated volumes / data.
To clarify, host path volumes will not be deleted which live outside the chart release dataset.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ChartReleaseApiChartReleaseIdIdDeleteRequest
*/
func (a *ChartReleaseApiService) ChartReleaseIdIdDelete(ctx context.Context, id string) ChartReleaseApiChartReleaseIdIdDeleteRequest {
	return ChartReleaseApiChartReleaseIdIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseIdIdDeleteExecute(r ChartReleaseApiChartReleaseIdIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseIdIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseIdIdGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	id         string
}

func (r ChartReleaseApiChartReleaseIdIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseIdIdGetExecute(r)
}

/*
ChartReleaseIdIdGet Method for ChartReleaseIdIdGet

Query available chart releases.

`query-options.extra.retrieve_resources` is a boolean when set will retrieve existing kubernetes resources
in the chart namespace.

`query-options.extra.history` is a boolean when set will retrieve all chart version upgrades
for a chart release.

`query-options.extra.include_chart_schema` is a boolean when set will retrieve the schema being used by
the chart release in question.

`query-options.extra.resource_events` is a boolean when set will retrieve individual events of each resource.
This only has effect if `query-options.extra.retrieve_resources` is set.

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ChartReleaseApiChartReleaseIdIdGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseIdIdGet(ctx context.Context, id string) ChartReleaseApiChartReleaseIdIdGetRequest {
	return ChartReleaseApiChartReleaseIdIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseIdIdGetExecute(r ChartReleaseApiChartReleaseIdIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseIdIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseIdIdPutRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	id         string
}

func (r ChartReleaseApiChartReleaseIdIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseIdIdPutExecute(r)
}

/*
ChartReleaseIdIdPut Method for ChartReleaseIdIdPut

Update an existing chart release.

`values` is configuration specified for the catalog item version in question which will be used to
create the chart release.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ChartReleaseApiChartReleaseIdIdPutRequest
*/
func (a *ChartReleaseApiService) ChartReleaseIdIdPut(ctx context.Context, id string) ChartReleaseApiChartReleaseIdIdPutRequest {
	return ChartReleaseApiChartReleaseIdIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseIdIdPutExecute(r ChartReleaseApiChartReleaseIdIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseIdIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseNicChoicesGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
}

func (r ChartReleaseApiChartReleaseNicChoicesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseNicChoicesGetExecute(r)
}

/*
ChartReleaseNicChoicesGet Method for ChartReleaseNicChoicesGet

Available choices for NIC which can be added to a pod in a chart release.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseNicChoicesGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseNicChoicesGet(ctx context.Context) ChartReleaseApiChartReleaseNicChoicesGetRequest {
	return ChartReleaseApiChartReleaseNicChoicesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseNicChoicesGetExecute(r ChartReleaseApiChartReleaseNicChoicesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseNicChoicesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/nic_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleasePodConsoleChoicesPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ChartReleaseApiChartReleasePodConsoleChoicesPostRequest) Body(body string) ChartReleaseApiChartReleasePodConsoleChoicesPostRequest {
	r.body = &body
	return r
}

func (r ChartReleaseApiChartReleasePodConsoleChoicesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePodConsoleChoicesPostExecute(r)
}

/*
ChartReleasePodConsoleChoicesPost Method for ChartReleasePodConsoleChoicesPost

Returns choices for console access to a chart release.

Output is a dictionary with names of pods as keys and containing names of containers which the pod
comprises of.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleasePodConsoleChoicesPostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePodConsoleChoicesPost(ctx context.Context) ChartReleaseApiChartReleasePodConsoleChoicesPostRequest {
	return ChartReleaseApiChartReleasePodConsoleChoicesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePodConsoleChoicesPostExecute(r ChartReleaseApiChartReleasePodConsoleChoicesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePodConsoleChoicesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/pod_console_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleasePodLogsChoicesPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ChartReleaseApiChartReleasePodLogsChoicesPostRequest) Body(body string) ChartReleaseApiChartReleasePodLogsChoicesPostRequest {
	r.body = &body
	return r
}

func (r ChartReleaseApiChartReleasePodLogsChoicesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePodLogsChoicesPostExecute(r)
}

/*
ChartReleasePodLogsChoicesPost Method for ChartReleasePodLogsChoicesPost

Returns choices for accessing logs of any container in any pod in a chart release.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleasePodLogsChoicesPostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePodLogsChoicesPost(ctx context.Context) ChartReleaseApiChartReleasePodLogsChoicesPostRequest {
	return ChartReleaseApiChartReleasePodLogsChoicesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePodLogsChoicesPostExecute(r ChartReleaseApiChartReleasePodLogsChoicesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePodLogsChoicesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/pod_logs_choices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleasePodLogsPostRequest struct {
	ctx                 context.Context
	ApiService          *ChartReleaseApiService
	chartReleasePodLogs *ChartReleasePodLogs
}

func (r ChartReleaseApiChartReleasePodLogsPostRequest) ChartReleasePodLogs(chartReleasePodLogs ChartReleasePodLogs) ChartReleaseApiChartReleasePodLogsPostRequest {
	r.chartReleasePodLogs = &chartReleasePodLogs
	return r
}

func (r ChartReleaseApiChartReleasePodLogsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePodLogsPostExecute(r)
}

/*
ChartReleasePodLogsPost Method for ChartReleasePodLogsPost

Export logs of `options.container_name` container in `options.pod_name` pod in `release_name` chart release.

`options.tail_lines` is an option to select how many lines of logs to retrieve for the said container. It
defaults to 500. If set to `null`, it will retrieve complete logs of the container.

`options.limit_bytes` is an option to select how many bytes to retrieve from the tail lines selected. If set
to null ( which is the default ), it will not limit the bytes returned. To clarify, `options.tail_lines`
is applied first and the required number of lines are retrieved and then `options.limit_bytes` is applied.

Please refer to websocket documentation for downloading the file.

A file will be downloaded from this endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleasePodLogsPostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePodLogsPost(ctx context.Context) ChartReleaseApiChartReleasePodLogsPostRequest {
	return ChartReleaseApiChartReleasePodLogsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePodLogsPostExecute(r ChartReleaseApiChartReleasePodLogsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePodLogsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/pod_logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleasePodLogs
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleasePodStatusPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ChartReleaseApiChartReleasePodStatusPostRequest) Body(body string) ChartReleaseApiChartReleasePodStatusPostRequest {
	r.body = &body
	return r
}

func (r ChartReleaseApiChartReleasePodStatusPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePodStatusPostExecute(r)
}

/*
ChartReleasePodStatusPost Method for ChartReleasePodStatusPost

Retrieve available/desired pods status for a chart release and it's current state.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleasePodStatusPostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePodStatusPost(ctx context.Context) ChartReleaseApiChartReleasePodStatusPostRequest {
	return ChartReleaseApiChartReleasePodStatusPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePodStatusPostExecute(r ChartReleaseApiChartReleasePodStatusPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePodStatusPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/pod_status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleasePostRequest struct {
	ctx                 context.Context
	ApiService          *ChartReleaseApiService
	chartReleaseCreate0 *ChartReleaseCreate0
}

func (r ChartReleaseApiChartReleasePostRequest) ChartReleaseCreate0(chartReleaseCreate0 ChartReleaseCreate0) ChartReleaseApiChartReleasePostRequest {
	r.chartReleaseCreate0 = &chartReleaseCreate0
	return r
}

func (r ChartReleaseApiChartReleasePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePostExecute(r)
}

/*
ChartReleasePost Method for ChartReleasePost

Create a chart release for a catalog item.

`release_name` is the name which will be used to identify the created chart release.

`catalog` is a valid catalog id where system will look for catalog `item` details.

`train` is which train to look for under `catalog` i.e stable / testing etc.

`version` specifies the catalog `item` version.

`values` is configuration specified for the catalog item version in question which will be used to
create the chart release.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleasePostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePost(ctx context.Context) ChartReleaseApiChartReleasePostRequest {
	return ChartReleaseApiChartReleasePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePostExecute(r ChartReleaseApiChartReleasePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseCreate0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleasePullContainerImagesPostRequest struct {
	ctx                             context.Context
	ApiService                      *ChartReleaseApiService
	chartReleasePullContainerImages *ChartReleasePullContainerImages
}

func (r ChartReleaseApiChartReleasePullContainerImagesPostRequest) ChartReleasePullContainerImages(chartReleasePullContainerImages ChartReleasePullContainerImages) ChartReleaseApiChartReleasePullContainerImagesPostRequest {
	r.chartReleasePullContainerImages = &chartReleasePullContainerImages
	return r
}

func (r ChartReleaseApiChartReleasePullContainerImagesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleasePullContainerImagesPostExecute(r)
}

/*
ChartReleasePullContainerImagesPost Method for ChartReleasePullContainerImagesPost

Update container images being used by `release_name` chart release.

`redeploy` when set will redeploy pods which will result in chart release using newer updated versions of
the container images.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleasePullContainerImagesPostRequest
*/
func (a *ChartReleaseApiService) ChartReleasePullContainerImagesPost(ctx context.Context) ChartReleaseApiChartReleasePullContainerImagesPostRequest {
	return ChartReleaseApiChartReleasePullContainerImagesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleasePullContainerImagesPostExecute(r ChartReleaseApiChartReleasePullContainerImagesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleasePullContainerImagesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/pull_container_images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleasePullContainerImages
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseRedeployPostRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
	body       *string
}

func (r ChartReleaseApiChartReleaseRedeployPostRequest) Body(body string) ChartReleaseApiChartReleaseRedeployPostRequest {
	r.body = &body
	return r
}

func (r ChartReleaseApiChartReleaseRedeployPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseRedeployPostExecute(r)
}

/*
ChartReleaseRedeployPost Method for ChartReleaseRedeployPost

Redeploy will initiate a new rollout of the Helm chart according to upgrade strategy defined by the chart release
workloads. A good example for redeploying is updating kubernetes pods with an updated container image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseRedeployPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseRedeployPost(ctx context.Context) ChartReleaseApiChartReleaseRedeployPostRequest {
	return ChartReleaseApiChartReleaseRedeployPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseRedeployPostExecute(r ChartReleaseApiChartReleaseRedeployPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseRedeployPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/redeploy"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseRemoveIxVolumePostRequest struct {
	ctx                        context.Context
	ApiService                 *ChartReleaseApiService
	chartReleaseRemoveIxVolume *ChartReleaseRemoveIxVolume
}

func (r ChartReleaseApiChartReleaseRemoveIxVolumePostRequest) ChartReleaseRemoveIxVolume(chartReleaseRemoveIxVolume ChartReleaseRemoveIxVolume) ChartReleaseApiChartReleaseRemoveIxVolumePostRequest {
	r.chartReleaseRemoveIxVolume = &chartReleaseRemoveIxVolume
	return r
}

func (r ChartReleaseApiChartReleaseRemoveIxVolumePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseRemoveIxVolumePostExecute(r)
}

/*
ChartReleaseRemoveIxVolumePost Method for ChartReleaseRemoveIxVolumePost

Remove `volume_name` ix_volume from `release_name` chart release.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseRemoveIxVolumePostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseRemoveIxVolumePost(ctx context.Context) ChartReleaseApiChartReleaseRemoveIxVolumePostRequest {
	return ChartReleaseApiChartReleaseRemoveIxVolumePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseRemoveIxVolumePostExecute(r ChartReleaseApiChartReleaseRemoveIxVolumePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseRemoveIxVolumePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/remove_ix_volume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseRemoveIxVolume
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseRollbackPostRequest struct {
	ctx                  context.Context
	ApiService           *ChartReleaseApiService
	chartReleaseRollback *ChartReleaseRollback
}

func (r ChartReleaseApiChartReleaseRollbackPostRequest) ChartReleaseRollback(chartReleaseRollback ChartReleaseRollback) ChartReleaseApiChartReleaseRollbackPostRequest {
	r.chartReleaseRollback = &chartReleaseRollback
	return r
}

func (r ChartReleaseApiChartReleaseRollbackPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseRollbackPostExecute(r)
}

/*
ChartReleaseRollbackPost Method for ChartReleaseRollbackPost

Rollback a chart release to a previous chart version.

`item_version` is version which we want to rollback a chart release to.

`rollback_snapshot` is a boolean value which when set will rollback snapshots of any PVC's or ix volumes being
consumed by the chart release.

`force_rollback` is a boolean which when set will force rollback operation to move forward even if no
snapshots are found. This is only useful when `rollback_snapshot` is set.

`recreate_resources` is a boolean which will delete and then create the kubernetes resources on rollback
of chart release. This should be used with caution as if chart release is consuming immutable objects like
a PVC, the rollback operation can't be performed and will fail as helm tries to do a 3 way patch for rollback.

Rollback is functional for the actual configuration of the release at the `item_version` specified and
any associated `ix_volumes` with any PVC's which were consuming chart release storage class.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseRollbackPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseRollbackPost(ctx context.Context) ChartReleaseApiChartReleaseRollbackPostRequest {
	return ChartReleaseApiChartReleaseRollbackPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseRollbackPostExecute(r ChartReleaseApiChartReleaseRollbackPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseRollbackPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/rollback"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseRollback
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseScalePostRequest struct {
	ctx               context.Context
	ApiService        *ChartReleaseApiService
	chartReleaseScale *ChartReleaseScale
}

func (r ChartReleaseApiChartReleaseScalePostRequest) ChartReleaseScale(chartReleaseScale ChartReleaseScale) ChartReleaseApiChartReleaseScalePostRequest {
	r.chartReleaseScale = &chartReleaseScale
	return r
}

func (r ChartReleaseApiChartReleaseScalePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseScalePostExecute(r)
}

/*
ChartReleaseScalePost Method for ChartReleaseScalePost

Scale a `release_name` chart release to `scale_options.replica_count` specified.

This will scale deployments/statefulset to replica count specified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseScalePostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseScalePost(ctx context.Context) ChartReleaseApiChartReleaseScalePostRequest {
	return ChartReleaseApiChartReleaseScalePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseScalePostExecute(r ChartReleaseApiChartReleaseScalePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseScalePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/scale"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseScale
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseScaleWorkloadsPostRequest struct {
	ctx                        context.Context
	ApiService                 *ChartReleaseApiService
	chartReleaseScaleWorkloads *ChartReleaseScaleWorkloads
}

func (r ChartReleaseApiChartReleaseScaleWorkloadsPostRequest) ChartReleaseScaleWorkloads(chartReleaseScaleWorkloads ChartReleaseScaleWorkloads) ChartReleaseApiChartReleaseScaleWorkloadsPostRequest {
	r.chartReleaseScaleWorkloads = &chartReleaseScaleWorkloads
	return r
}

func (r ChartReleaseApiChartReleaseScaleWorkloadsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseScaleWorkloadsPostExecute(r)
}

/*
ChartReleaseScaleWorkloadsPost Method for ChartReleaseScaleWorkloadsPost

Scale workloads in a chart release to specified `replica_count`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseScaleWorkloadsPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseScaleWorkloadsPost(ctx context.Context) ChartReleaseApiChartReleaseScaleWorkloadsPostRequest {
	return ChartReleaseApiChartReleaseScaleWorkloadsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseScaleWorkloadsPostExecute(r ChartReleaseApiChartReleaseScaleWorkloadsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseScaleWorkloadsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/scale_workloads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseScaleWorkloads
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseScaleableResourcesGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
}

func (r ChartReleaseApiChartReleaseScaleableResourcesGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseScaleableResourcesGetExecute(r)
}

/*
ChartReleaseScaleableResourcesGet Method for ChartReleaseScaleableResourcesGet

Returns choices for types of workloads which can be scaled up/down.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseScaleableResourcesGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseScaleableResourcesGet(ctx context.Context) ChartReleaseApiChartReleaseScaleableResourcesGetRequest {
	return ChartReleaseApiChartReleaseScaleableResourcesGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseScaleableResourcesGetExecute(r ChartReleaseApiChartReleaseScaleableResourcesGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseScaleableResourcesGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/scaleable_resources"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseUpgradePostRequest struct {
	ctx                 context.Context
	ApiService          *ChartReleaseApiService
	chartReleaseUpgrade *ChartReleaseUpgrade
}

func (r ChartReleaseApiChartReleaseUpgradePostRequest) ChartReleaseUpgrade(chartReleaseUpgrade ChartReleaseUpgrade) ChartReleaseApiChartReleaseUpgradePostRequest {
	r.chartReleaseUpgrade = &chartReleaseUpgrade
	return r
}

func (r ChartReleaseApiChartReleaseUpgradePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseUpgradePostExecute(r)
}

/*
ChartReleaseUpgradePost Method for ChartReleaseUpgradePost

Upgrade `release_name` chart release.

`upgrade_options.item_version` specifies to which item version chart release should be upgraded to.

System will update container images being used by `release_name` chart release as a chart release
upgrade is not considered complete until the images in use have also been updated to latest versions.

During upgrade, `upgrade_options.values` can be specified to apply configuration changes for configuration
changes for the chart release in question.

When chart version is upgraded, system will automatically take a snapshot of `ix_volumes` in question
which can be used to rollback later on.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseUpgradePostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseUpgradePost(ctx context.Context) ChartReleaseApiChartReleaseUpgradePostRequest {
	return ChartReleaseApiChartReleaseUpgradePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseUpgradePostExecute(r ChartReleaseApiChartReleaseUpgradePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseUpgradePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/upgrade"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseUpgrade
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseUpgradeSummaryPostRequest struct {
	ctx                        context.Context
	ApiService                 *ChartReleaseApiService
	chartReleaseUpgradeSummary *ChartReleaseUpgradeSummary
}

func (r ChartReleaseApiChartReleaseUpgradeSummaryPostRequest) ChartReleaseUpgradeSummary(chartReleaseUpgradeSummary ChartReleaseUpgradeSummary) ChartReleaseApiChartReleaseUpgradeSummaryPostRequest {
	r.chartReleaseUpgradeSummary = &chartReleaseUpgradeSummary
	return r
}

func (r ChartReleaseApiChartReleaseUpgradeSummaryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseUpgradeSummaryPostExecute(r)
}

/*
ChartReleaseUpgradeSummaryPost Method for ChartReleaseUpgradeSummaryPost

Retrieve upgrade summary for `release_name` which will include which container images will be updated
and changelog for `options.item_version` chart version specified if applicable. If only container images
need to be updated, changelog will be `null`.

If chart release `release_name` does not require an upgrade, an error will be raised.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseUpgradeSummaryPostRequest
*/
func (a *ChartReleaseApiService) ChartReleaseUpgradeSummaryPost(ctx context.Context) ChartReleaseApiChartReleaseUpgradeSummaryPostRequest {
	return ChartReleaseApiChartReleaseUpgradeSummaryPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseUpgradeSummaryPostExecute(r ChartReleaseApiChartReleaseUpgradeSummaryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseUpgradeSummaryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/upgrade_summary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chartReleaseUpgradeSummary
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ChartReleaseApiChartReleaseUsedPortsGetRequest struct {
	ctx        context.Context
	ApiService *ChartReleaseApiService
}

func (r ChartReleaseApiChartReleaseUsedPortsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChartReleaseUsedPortsGetExecute(r)
}

/*
ChartReleaseUsedPortsGet Method for ChartReleaseUsedPortsGet

Returns ports in use by applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ChartReleaseApiChartReleaseUsedPortsGetRequest
*/
func (a *ChartReleaseApiService) ChartReleaseUsedPortsGet(ctx context.Context) ChartReleaseApiChartReleaseUsedPortsGetRequest {
	return ChartReleaseApiChartReleaseUsedPortsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *ChartReleaseApiService) ChartReleaseUsedPortsGetExecute(r ChartReleaseApiChartReleaseUsedPortsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChartReleaseApiService.ChartReleaseUsedPortsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chart/release/used_ports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
