/*
TrueNAS RESTful API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package truenas

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// CloudsyncApiService CloudsyncApi service
type CloudsyncApiService service

type CloudsyncApiCloudsyncGetRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	limit      *int32
	offset     *int32
	count      *bool
	sort       *string
}

func (r CloudsyncApiCloudsyncGetRequest) Limit(limit int32) CloudsyncApiCloudsyncGetRequest {
	r.limit = &limit
	return r
}

func (r CloudsyncApiCloudsyncGetRequest) Offset(offset int32) CloudsyncApiCloudsyncGetRequest {
	r.offset = &offset
	return r
}

func (r CloudsyncApiCloudsyncGetRequest) Count(count bool) CloudsyncApiCloudsyncGetRequest {
	r.count = &count
	return r
}

func (r CloudsyncApiCloudsyncGetRequest) Sort(sort string) CloudsyncApiCloudsyncGetRequest {
	r.sort = &sort
	return r
}

func (r CloudsyncApiCloudsyncGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncGetExecute(r)
}

/*
CloudsyncGet Method for CloudsyncGet

Query all Cloud Sync Tasks with `query-filters` and `query-options`.

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CloudsyncApiCloudsyncGetRequest
*/
func (a *CloudsyncApiService) CloudsyncGet(ctx context.Context) CloudsyncApiCloudsyncGetRequest {
	return CloudsyncApiCloudsyncGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncGetExecute(r CloudsyncApiCloudsyncGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.count != nil {
		localVarQueryParams.Add("count", parameterToString(*r.count, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncIdIdAbortPostRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	id         int32
}

func (r CloudsyncApiCloudsyncIdIdAbortPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdAbortPostExecute(r)
}

/*
CloudsyncIdIdAbortPost Method for CloudsyncIdIdAbortPost

Aborts cloud sync task.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return CloudsyncApiCloudsyncIdIdAbortPostRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdAbortPost(ctx context.Context, id int32) CloudsyncApiCloudsyncIdIdAbortPostRequest {
	return CloudsyncApiCloudsyncIdIdAbortPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdAbortPostExecute(r CloudsyncApiCloudsyncIdIdAbortPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdAbortPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}/abort"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncIdIdDeleteRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	id         int32
}

func (r CloudsyncApiCloudsyncIdIdDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdDeleteExecute(r)
}

/*
CloudsyncIdIdDelete Method for CloudsyncIdIdDelete

Deletes cloud_sync entry `id`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return CloudsyncApiCloudsyncIdIdDeleteRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdDelete(ctx context.Context, id int32) CloudsyncApiCloudsyncIdIdDeleteRequest {
	return CloudsyncApiCloudsyncIdIdDeleteRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdDeleteExecute(r CloudsyncApiCloudsyncIdIdDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncIdIdGetRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	id         int32
}

func (r CloudsyncApiCloudsyncIdIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdGetExecute(r)
}

/*
CloudsyncIdIdGet Method for CloudsyncIdIdGet

Query all Cloud Sync Tasks with `query-filters` and `query-options`.

`query-options.extra` can be specified as query parameters with prefixing them with `extra.` prefix. For example, `extra.retrieve_properties=false` will pass `retrieve_properties` as an extra argument to pool/dataset endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return CloudsyncApiCloudsyncIdIdGetRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdGet(ctx context.Context, id int32) CloudsyncApiCloudsyncIdIdGetRequest {
	return CloudsyncApiCloudsyncIdIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdGetExecute(r CloudsyncApiCloudsyncIdIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncIdIdPutRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	id         int32
}

func (r CloudsyncApiCloudsyncIdIdPutRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdPutExecute(r)
}

/*
CloudsyncIdIdPut Method for CloudsyncIdIdPut

Updates the cloud_sync entry `id` with `data`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return CloudsyncApiCloudsyncIdIdPutRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdPut(ctx context.Context, id int32) CloudsyncApiCloudsyncIdIdPutRequest {
	return CloudsyncApiCloudsyncIdIdPutRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdPutExecute(r CloudsyncApiCloudsyncIdIdPutRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdPut")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncIdIdRestorePostRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	id         int32
}

func (r CloudsyncApiCloudsyncIdIdRestorePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdRestorePostExecute(r)
}

/*
CloudsyncIdIdRestorePost Method for CloudsyncIdIdRestorePost

Create the opposite of cloud sync task `id` (PULL if it was PUSH and vice versa).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return CloudsyncApiCloudsyncIdIdRestorePostRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdRestorePost(ctx context.Context, id int32) CloudsyncApiCloudsyncIdIdRestorePostRequest {
	return CloudsyncApiCloudsyncIdIdRestorePostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdRestorePostExecute(r CloudsyncApiCloudsyncIdIdRestorePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdRestorePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncIdIdSyncPostRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	id         int32
}

func (r CloudsyncApiCloudsyncIdIdSyncPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncIdIdSyncPostExecute(r)
}

/*
CloudsyncIdIdSyncPost Method for CloudsyncIdIdSyncPost

Run the cloud_sync job `id`, syncing the local data to remote.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return CloudsyncApiCloudsyncIdIdSyncPostRequest
*/
func (a *CloudsyncApiService) CloudsyncIdIdSyncPost(ctx context.Context, id int32) CloudsyncApiCloudsyncIdIdSyncPostRequest {
	return CloudsyncApiCloudsyncIdIdSyncPostRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncIdIdSyncPostExecute(r CloudsyncApiCloudsyncIdIdSyncPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncIdIdSyncPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/id/{id}/sync"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncListBucketsPostRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
	body       *int32
}

func (r CloudsyncApiCloudsyncListBucketsPostRequest) Body(body int32) CloudsyncApiCloudsyncListBucketsPostRequest {
	r.body = &body
	return r
}

func (r CloudsyncApiCloudsyncListBucketsPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncListBucketsPostExecute(r)
}

/*
CloudsyncListBucketsPost Method for CloudsyncListBucketsPost



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CloudsyncApiCloudsyncListBucketsPostRequest
*/
func (a *CloudsyncApiService) CloudsyncListBucketsPost(ctx context.Context) CloudsyncApiCloudsyncListBucketsPostRequest {
	return CloudsyncApiCloudsyncListBucketsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncListBucketsPostExecute(r CloudsyncApiCloudsyncListBucketsPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncListBucketsPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/list_buckets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncListDirectoryPostRequest struct {
	ctx                     context.Context
	ApiService              *CloudsyncApiService
	cloudsyncListDirectory0 *CloudsyncListDirectory0
}

func (r CloudsyncApiCloudsyncListDirectoryPostRequest) CloudsyncListDirectory0(cloudsyncListDirectory0 CloudsyncListDirectory0) CloudsyncApiCloudsyncListDirectoryPostRequest {
	r.cloudsyncListDirectory0 = &cloudsyncListDirectory0
	return r
}

func (r CloudsyncApiCloudsyncListDirectoryPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncListDirectoryPostExecute(r)
}

/*
CloudsyncListDirectoryPost Method for CloudsyncListDirectoryPost

List contents of a remote bucket / directory.

If remote supports buckets, path is constructed by two keys "bucket"/"folder" in `attributes`.
If remote does not support buckets, path is constructed using "folder" key only in `attributes`.
"folder" is directory name and "bucket" is bucket name for remote.

Path examples:

S3 Service
`bucketname/directory/name`

Dropbox Service
`directory/name`

`credentials` is a valid id of a Cloud Sync Credential which will be used to connect to the provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CloudsyncApiCloudsyncListDirectoryPostRequest
*/
func (a *CloudsyncApiService) CloudsyncListDirectoryPost(ctx context.Context) CloudsyncApiCloudsyncListDirectoryPostRequest {
	return CloudsyncApiCloudsyncListDirectoryPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncListDirectoryPostExecute(r CloudsyncApiCloudsyncListDirectoryPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncListDirectoryPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/list_directory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncListDirectory0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncOnedriveListDrivesPostRequest struct {
	ctx                          context.Context
	ApiService                   *CloudsyncApiService
	cloudsyncOnedriveListDrives0 *CloudsyncOnedriveListDrives0
}

func (r CloudsyncApiCloudsyncOnedriveListDrivesPostRequest) CloudsyncOnedriveListDrives0(cloudsyncOnedriveListDrives0 CloudsyncOnedriveListDrives0) CloudsyncApiCloudsyncOnedriveListDrivesPostRequest {
	r.cloudsyncOnedriveListDrives0 = &cloudsyncOnedriveListDrives0
	return r
}

func (r CloudsyncApiCloudsyncOnedriveListDrivesPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncOnedriveListDrivesPostExecute(r)
}

/*
CloudsyncOnedriveListDrivesPost Method for CloudsyncOnedriveListDrivesPost

Lists all available drives and their types for given Microsoft OneDrive credentials.




 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CloudsyncApiCloudsyncOnedriveListDrivesPostRequest
*/
func (a *CloudsyncApiService) CloudsyncOnedriveListDrivesPost(ctx context.Context) CloudsyncApiCloudsyncOnedriveListDrivesPostRequest {
	return CloudsyncApiCloudsyncOnedriveListDrivesPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncOnedriveListDrivesPostExecute(r CloudsyncApiCloudsyncOnedriveListDrivesPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncOnedriveListDrivesPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/onedrive_list_drives"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncOnedriveListDrives0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncPostRequest struct {
	ctx              context.Context
	ApiService       *CloudsyncApiService
	cloudsyncCreate0 *CloudsyncCreate0
}

func (r CloudsyncApiCloudsyncPostRequest) CloudsyncCreate0(cloudsyncCreate0 CloudsyncCreate0) CloudsyncApiCloudsyncPostRequest {
	r.cloudsyncCreate0 = &cloudsyncCreate0
	return r
}

func (r CloudsyncApiCloudsyncPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncPostExecute(r)
}

/*
CloudsyncPost Method for CloudsyncPost

Creates a new cloud_sync entry.



 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CloudsyncApiCloudsyncPostRequest
*/
func (a *CloudsyncApiService) CloudsyncPost(ctx context.Context) CloudsyncApiCloudsyncPostRequest {
	return CloudsyncApiCloudsyncPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncPostExecute(r CloudsyncApiCloudsyncPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncCreate0
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncProvidersGetRequest struct {
	ctx        context.Context
	ApiService *CloudsyncApiService
}

func (r CloudsyncApiCloudsyncProvidersGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncProvidersGetExecute(r)
}

/*
CloudsyncProvidersGet Method for CloudsyncProvidersGet

Returns a list of dictionaries of supported providers for Cloud Sync Tasks.

`credentials_schema` is JSON schema for credentials attributes.

`task_schema` is JSON schema for task attributes.

`buckets` is a boolean value which is set to "true" if provider supports buckets.

Example of a single provider:

[

    {
        "name": "AMAZON_CLOUD_DRIVE",
        "title": "Amazon Cloud Drive",
        "credentials_schema": [
            {
                "property": "client_id",
                "schema": {
                    "title": "Amazon Application Client ID",
                    "_required_": true,
                    "type": "string"
                }
            },
            {
                "property": "client_secret",
                "schema": {
                    "title": "Application Key",
                    "_required_": true,
                    "type": "string"
                }
            }
        ],
        "credentials_oauth": null,
        "buckets": false,
        "bucket_title": "Bucket",
        "task_schema": []
    }
]

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CloudsyncApiCloudsyncProvidersGetRequest
*/
func (a *CloudsyncApiService) CloudsyncProvidersGet(ctx context.Context) CloudsyncApiCloudsyncProvidersGetRequest {
	return CloudsyncApiCloudsyncProvidersGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncProvidersGetExecute(r CloudsyncApiCloudsyncProvidersGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncProvidersGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type CloudsyncApiCloudsyncSyncOnetimePostRequest struct {
	ctx                  context.Context
	ApiService           *CloudsyncApiService
	cloudsyncSyncOnetime *CloudsyncSyncOnetime
}

func (r CloudsyncApiCloudsyncSyncOnetimePostRequest) CloudsyncSyncOnetime(cloudsyncSyncOnetime CloudsyncSyncOnetime) CloudsyncApiCloudsyncSyncOnetimePostRequest {
	r.cloudsyncSyncOnetime = &cloudsyncSyncOnetime
	return r
}

func (r CloudsyncApiCloudsyncSyncOnetimePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.CloudsyncSyncOnetimePostExecute(r)
}

/*
CloudsyncSyncOnetimePost Method for CloudsyncSyncOnetimePost

Run cloud sync task without creating it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return CloudsyncApiCloudsyncSyncOnetimePostRequest
*/
func (a *CloudsyncApiService) CloudsyncSyncOnetimePost(ctx context.Context) CloudsyncApiCloudsyncSyncOnetimePostRequest {
	return CloudsyncApiCloudsyncSyncOnetimePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *CloudsyncApiService) CloudsyncSyncOnetimePostExecute(r CloudsyncApiCloudsyncSyncOnetimePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CloudsyncApiService.CloudsyncSyncOnetimePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cloudsync/sync_onetime"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cloudsyncSyncOnetime
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
